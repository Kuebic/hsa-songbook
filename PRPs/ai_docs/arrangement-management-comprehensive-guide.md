# Arrangement Management Comprehensive Implementation Guide

## Overview

This guide provides critical implementation patterns for the arrangement management feature in HSA Songbook. It synthesizes research from React 19, TypeScript, Vite, music libraries, and existing codebase patterns.

---

## Musical Metadata Schema (Critical Foundation)

### Arrangement Data Structure
```typescript
interface Arrangement {
  id: string
  name: string                // User-editable portion only
  song_id: string
  slug: string               // Auto-generated from song + arrangement name
  
  // Musical Properties (REQUIRED for transposition)
  key: string               // MUST be required - "C", "Am", "F#", etc.
  tempo?: number            // Optional - BPM (40-240)
  time_signature: string    // Default "4/4" - "3/4", "6/8", etc.
  difficulty: 'beginner' | 'intermediate' | 'advanced'  // User-selected
  
  // Content & Organization
  chord_data?: string       // ChordPro format, filled later in editor
  description?: string      // Optional description
  tags: string[]           // Similar to song themes, max 10
  
  // Auto-Generated Metadata
  auto_generated_title: string  // "[Song Name] - [Arrangement Name]"
  
  // Tracking
  created_by: string
  created_at: string
  updated_at: string
  is_public: boolean
}
```

### Musical Key Validation with Tonal.js
```typescript
import { Key } from 'tonal'

const MUSICAL_KEYS = [
  'C', 'C#', 'Db', 'D', 'D#', 'Eb', 'E', 'F', 
  'F#', 'Gb', 'G', 'G#', 'Ab', 'A', 'A#', 'Bb', 'B',
  'Cm', 'C#m', 'Dm', 'D#m', 'Em', 'Fm', 
  'F#m', 'Gm', 'G#m', 'Am', 'A#m', 'Bm'
] as const

const validateMusicalKey = (key: string): boolean => {
  try {
    const keyInfo = Key.majorKey(key.replace('m', ''))
    return keyInfo.keySignature !== undefined
  } catch {
    return MUSICAL_KEYS.includes(key as any)
  }
}
```

---

## Form Implementation Patterns (Based on SongManagementForm)

### Complete Form Structure Pattern
```typescript
interface ArrangementFormState {
  name: string              // Only editable part of title
  key: string              // REQUIRED
  tempo: string            // Optional, stored as string for form
  timeSignature: string    // Default "4/4"
  difficulty: string       // Required selection
  tags: string[]          // Max 10, similar to themes
  description: string      // Optional
}

interface ArrangementValidationErrors {
  name?: string
  key?: string
  tempo?: string
  timeSignature?: string
  difficulty?: string
  tags?: string
  description?: string
}

// Critical Pattern: Mirror SongManagementForm structure exactly
export function ArrangementManagementForm({ 
  song,
  arrangement, 
  onSuccess, 
  onCancel, 
  isModal = false 
}: ArrangementManagementFormProps) {
  // State management (exactly like SongManagementForm)
  const [formState, setFormState] = useState<ArrangementFormState>({
    name: arrangement?.name || '',
    key: arrangement?.key || '',
    tempo: arrangement?.tempo?.toString() || '',
    timeSignature: arrangement?.time_signature || '4/4',
    difficulty: arrangement?.difficulty || '',
    tags: arrangement?.tags || [],
    description: arrangement?.description || ''
  })
  
  const [validationErrors, setValidationErrors] = useState<ArrangementValidationErrors>({})
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [tagInput, setTagInput] = useState('')
  
  // Auto-generated title computation
  const autoGeneratedTitle = useMemo(() => {
    if (!song?.title || !formState.name.trim()) return ''
    return `${song.title} - ${formState.name.trim()}`
  }, [song?.title, formState.name])
  
  // Field change handler (exact pattern from SongManagementForm)
  const handleFieldChange = (field: keyof ArrangementFormState, value: string | string[]) => {
    setFormState(prev => ({ ...prev, [field]: value }))
    setValidationErrors(prev => ({ ...prev, [field]: undefined }))
  }
  
  // Form validation (following songFormSchema pattern)
  const validateForm = (): boolean => {
    const errors: ArrangementValidationErrors = {}
    
    const dataToValidate = {
      name: formState.name,
      key: formState.key,
      tempo: formState.tempo ? parseInt(formState.tempo) : undefined,
      timeSignature: formState.timeSignature,
      difficulty: formState.difficulty,
      tags: formState.tags,
      description: formState.description || undefined
    }
    
    const result = arrangementSchema.safeParse(dataToValidate)
    
    if (!result.success) {
      result.error.issues.forEach(issue => {
        const field = issue.path[0] as keyof ArrangementValidationErrors
        errors[field] = issue.message
      })
      setValidationErrors(errors)
      return false
    }
    
    setValidationErrors({})
    return true
  }
}
```

---

## ChordPro Editor Integration Patterns

### Pre-fill ChordPro Content
```typescript
// Pattern: Generate ChordPro template with arrangement metadata
const generateChordProTemplate = (
  arrangement: Arrangement, 
  song: Song
): string => {
  const template = [
    `{title: ${arrangement.auto_generated_title}}`,
    song.artist ? `{artist: ${song.artist}}` : '',
    `{key: ${arrangement.key}}`,
    arrangement.tempo ? `{tempo: ${arrangement.tempo}}` : '',
    arrangement.time_signature ? `{time: ${arrangement.time_signature}}` : '',
    arrangement.difficulty ? `{difficulty: ${arrangement.difficulty}}` : '',
    '',
    '# Add your chord progressions and lyrics here',
    '# Example:',
    '# [C]Amazing [F]grace, how [C]sweet the [G]sound',
    '# That [C]saved a [F]wretch like [C]me',
    ''
  ].filter(Boolean).join('\n')
  
  return template
}

// Navigation to ChordPro editor with pre-filled content
const navigateToChordProEditor = (arrangement: Arrangement) => {
  const template = generateChordProTemplate(arrangement, song)
  const url = `/arrangements/${arrangement.id}/edit?prefill=true`
  
  // Store template in sessionStorage for editor to pick up
  sessionStorage.setItem(`chordpro-template-${arrangement.id}`, template)
  
  // Navigate to editor
  router.push(url)
}
```

---

## Validation Schema Patterns (Critical - Follow Exact Pattern)

### Zod Schema with Musical Validation
```typescript
import { z } from 'zod'
import { MUSICAL_KEYS, TIME_SIGNATURES, DIFFICULTY_LEVELS } from '../constants/musicalKeys'

// Critical: Follow exact pattern from songFormSchema.ts
export const arrangementSchema = z.object({
  // Basic Information
  name: z.string()
    .min(1, 'Arrangement name is required')
    .max(100, 'Arrangement name must be less than 100 characters')
    .trim()
    .refine(
      (val) => val.length > 0,
      { message: 'Arrangement name cannot be only whitespace' }
    ),
  
  // Musical Properties - REQUIRED KEY
  key: z.enum(MUSICAL_KEYS as readonly [string, ...string[]])
    .describe('Musical key is required for transposition'),
  
  tempo: z.number()
    .min(40, 'Tempo must be at least 40 BPM')
    .max(240, 'Tempo must be less than 240 BPM')
    .int('Tempo must be a whole number')
    .optional(),
  
  timeSignature: z.enum(TIME_SIGNATURES as readonly [string, ...string[]])
    .default('4/4'),
  
  difficulty: z.enum(DIFFICULTY_LEVELS as readonly [string, ...string[]])
    .describe('Please select a difficulty level'),
  
  // Tags (similar to song themes)
  tags: z.array(
    z.string()
      .min(1, 'Tag cannot be empty')
      .max(50, 'Tag must be less than 50 characters')
      .trim()
  )
    .max(10, 'Maximum 10 tags allowed')
    .default([]),
  
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional()
    .transform(val => val && val.length > 0 ? val : undefined),
  
  // Auto-generated fields
  songId: z.string().uuid('Invalid song ID'),
  autoGeneratedTitle: z.string().optional()
})

export type ArrangementFormData = z.infer<typeof arrangementSchema>

// Field-level schemas for inline editing
export const arrangementFieldSchemas = {
  name: arrangementSchema.shape.name,
  key: arrangementSchema.shape.key,
  tempo: arrangementSchema.shape.tempo,
  timeSignature: arrangementSchema.shape.timeSignature,
  difficulty: arrangementSchema.shape.difficulty,
  tags: arrangementSchema.shape.tags,
  description: arrangementSchema.shape.description
} as const
```

---

## Mutation Hooks Pattern (Critical - Follow useSongMutations)

### Complete Mutation Hook Structure
```typescript
// Pattern: Follow exact structure from songs feature hooks
export function useArrangementMutations(props: UseArrangementMutationsProps = {}) {
  const { onSuccess, onError, ...queryOptions } = props
  const queryClient = useQueryClient()
  const { addNotification } = useNotification()
  
  // Create arrangement mutation
  const createArrangement = useMutation({
    mutationFn: async (formData: ArrangementFormData): Promise<Arrangement> => {
      // Validate data
      const validatedData = arrangementSchema.parse(formData)
      
      // Create arrangement via service
      const newArrangement = await arrangementService.createArrangement({
        ...validatedData,
        auto_generated_title: `${song.title} - ${validatedData.name}`
      })
      
      return newArrangement
    },
    
    onSuccess: (arrangement, variables) => {
      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: ['arrangements'] })
      queryClient.invalidateQueries({ queryKey: ['song', arrangement.song_id] })
      
      // Show success notification
      addNotification({
        type: 'success',
        title: 'Arrangement Created',
        message: `"${arrangement.auto_generated_title}" has been created`
      })
      
      onSuccess?.(arrangement)
    },
    
    onError: (error, variables) => {
      console.error('Failed to create arrangement:', error)
      
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Failed to create arrangement'
      
      addNotification({
        type: 'error',
        title: 'Creation Failed',
        message: errorMessage
      })
      
      onError?.(error)
    }
  })
  
  return {
    createArrangement: createArrangement.mutate,
    createArrangementAsync: createArrangement.mutateAsync,
    isCreating: createArrangement.isPending,
    createError: createArrangement.error
  }
}

// Specialized hooks (following pattern from useCreateSong.ts)
export function useCreateArrangement(options: UseCreateArrangementOptions = {}) {
  const { onSuccess, onError, ...mutationProps } = options
  const { createArrangement, isCreating, createError } = useArrangementMutations(mutationProps)
  
  const handleCreate = useCallback(async (formData: ArrangementFormData) => {
    try {
      const newArrangement = await createArrangementAsync(formData)
      onSuccess?.(newArrangement)
      return newArrangement
    } catch (err) {
      onError?.(err)
      throw err
    }
  }, [createArrangementAsync, onSuccess, onError])
  
  return { 
    createArrangement: handleCreate, 
    isCreating, 
    error: createError 
  }
}
```

---

## Testing Patterns (Critical - Follow Existing Test Structure)

### Component Test Structure
```typescript
// Follow exact pattern from SongManagementForm.test.tsx
describe('ArrangementManagementForm', () => {
  const mockSong: Song = {
    id: 'song-1',
    title: 'Amazing Grace',
    artist: 'John Newton',
    // ... other fields
  }
  
  beforeEach(() => {
    vi.clearAllMocks()
  })
  
  describe('Form Rendering', () => {
    it('should render all required form fields', () => {
      render(<ArrangementManagementForm song={mockSong} />)
      
      expect(screen.getByLabelText(/arrangement name/i)).toBeInTheDocument()
      expect(screen.getByLabelText(/key/i)).toBeInTheDocument()
      expect(screen.getByLabelText(/difficulty/i)).toBeInTheDocument()
      expect(screen.getByText(/amazing grace -/i)).toBeInTheDocument() // Auto-generated title
    })
    
    it('should pre-populate fields when editing', () => {
      const arrangement = {
        name: 'Piano Arrangement',
        key: 'C',
        difficulty: 'intermediate'
      }
      
      render(<ArrangementManagementForm song={mockSong} arrangement={arrangement} />)
      
      expect(screen.getByDisplayValue('Piano Arrangement')).toBeInTheDocument()
      expect(screen.getByDisplayValue('C')).toBeInTheDocument()
    })
  })
  
  describe('Musical Validation', () => {
    it('should require musical key', async () => {
      render(<ArrangementManagementForm song={mockSong} />)
      
      await userEvent.type(screen.getByLabelText(/arrangement name/i), 'Test')
      fireEvent.click(screen.getByRole('button', { name: /create arrangement/i }))
      
      await waitFor(() => {
        expect(screen.getByText(/musical key is required/i)).toBeInTheDocument()
      })
    })
    
    it('should validate tempo range', async () => {
      render(<ArrangementManagementForm song={mockSong} />)
      
      await userEvent.type(screen.getByLabelText(/tempo/i), '300')
      fireEvent.blur(screen.getByLabelText(/tempo/i))
      
      await waitFor(() => {
        expect(screen.getByText(/tempo must be less than 240/i)).toBeInTheDocument()
      })
    })
  })
  
  describe('Auto-Generated Title', () => {
    it('should generate title from song and arrangement name', async () => {
      render(<ArrangementManagementForm song={mockSong} />)
      
      await userEvent.type(screen.getByLabelText(/arrangement name/i), 'Guitar Version')
      
      await waitFor(() => {
        expect(screen.getByText(/amazing grace - guitar version/i)).toBeInTheDocument()
      })
    })
  })
  
  describe('Form Submission', () => {
    it('should call onSuccess callback after successful creation', async () => {
      const onSuccess = vi.fn()
      const mockCreate = vi.fn().mockResolvedValue({
        id: 'arr-1',
        auto_generated_title: 'Amazing Grace - Piano Version'
      })
      
      vi.mocked(useCreateArrangement).mockReturnValue({
        createArrangement: mockCreate,
        isCreating: false,
        error: null
      })
      
      render(<ArrangementManagementForm song={mockSong} onSuccess={onSuccess} />)
      
      await userEvent.type(screen.getByLabelText(/arrangement name/i), 'Piano Version')
      await userEvent.selectOptions(screen.getByLabelText(/key/i), 'C')
      await userEvent.selectOptions(screen.getByLabelText(/difficulty/i), 'intermediate')
      
      fireEvent.click(screen.getByRole('button', { name: /create arrangement/i }))
      
      await waitFor(() => {
        expect(mockCreate).toHaveBeenCalledWith(
          expect.objectContaining({
            name: 'Piano Version',
            key: 'C',
            difficulty: 'intermediate'
          })
        )
        expect(onSuccess).toHaveBeenCalled()
      })
    })
  })
})
```

---

## Service Layer Pattern (Critical - Follow songService.ts)

### Complete Service Implementation
```typescript
// Follow exact pattern from songService.ts
import { supabase } from '@lib/supabase'
import type { Arrangement, ArrangementFormData } from '../types/arrangement.types'

export const arrangementService = {
  async createArrangement(data: ArrangementFormData): Promise<Arrangement> {
    const { data: user } = await supabase.auth.getUser()
    if (!user?.user) throw new Error('Authentication required')
    
    // Generate slug (following song slug pattern)
    const slug = await generateArrangementSlug(data.name, data.songId)
    
    const arrangementData = {
      name: data.name.trim(),
      song_id: data.songId,
      slug,
      key: data.key,
      tempo: data.tempo || null,
      time_signature: data.timeSignature || '4/4',
      difficulty: data.difficulty,
      description: data.description || null,
      tags: data.tags || [],
      created_by: user.user.id,
      is_public: false
    }
    
    const { data: arrangement, error } = await supabase
      .from('arrangements')
      .insert(arrangementData)
      .select(`
        *,
        song:songs(title, artist)
      `)
      .single()
    
    if (error) throw error
    if (!arrangement) throw new Error('Failed to create arrangement')
    
    // Clear relevant caches
    clearArrangementCaches()
    
    return mapSupabaseArrangementToArrangement(arrangement)
  },
  
  async getArrangementsBySong(songId: string): Promise<Arrangement[]> {
    const cacheKey = `arrangements-${songId}`
    const cached = getCachedResult<Arrangement[]>(cacheKey)
    if (cached) return cached
    
    const { data: arrangements, error } = await supabase
      .from('arrangements')
      .select(`
        *,
        song:songs(title, artist)
      `)
      .eq('song_id', songId)
      .order('created_at', { ascending: false })
    
    if (error) throw error
    
    const mappedArrangements = arrangements.map(mapSupabaseArrangementToArrangement)
    
    // Cache results
    setCachedResult(cacheKey, mappedArrangements)
    
    return mappedArrangements
  }
}

// Type mapping function (following song service pattern)
function mapSupabaseArrangementToArrangement(supabaseArr: any): Arrangement {
  return {
    id: supabaseArr.id,
    name: supabaseArr.name,
    song_id: supabaseArr.song_id,
    slug: supabaseArr.slug,
    key: supabaseArr.key,
    tempo: supabaseArr.tempo,
    time_signature: supabaseArr.time_signature,
    difficulty: supabaseArr.difficulty,
    description: supabaseArr.description,
    tags: supabaseArr.tags || [],
    chord_data: supabaseArr.chord_data,
    auto_generated_title: `${supabaseArr.song?.title || 'Unknown'} - ${supabaseArr.name}`,
    created_by: supabaseArr.created_by,
    created_at: supabaseArr.created_at,
    updated_at: supabaseArr.updated_at,
    is_public: supabaseArr.is_public
  }
}
```

---

## Performance Optimization (React 19 Patterns)

### Optimistic Updates with useOptimistic
```typescript
import { useOptimistic, useTransition } from 'react'

export function useOptimisticArrangements(songId: string) {
  const { data: arrangements = [] } = useArrangements(songId)
  const [isPending, startTransition] = useTransition()
  
  const [optimisticArrangements, addOptimisticArrangement] = useOptimistic(
    arrangements,
    (state, newArrangement: Arrangement) => [
      ...state,
      { ...newArrangement, id: `temp-${Date.now()}` }
    ]
  )
  
  const createArrangementOptimistic = useCallback((formData: ArrangementFormData) => {
    const optimisticArr: Arrangement = {
      ...formData,
      id: `temp-${Date.now()}`,
      auto_generated_title: `${song.title} - ${formData.name}`,
      created_at: new Date().toISOString(),
      // ... other required fields
    }
    
    startTransition(() => {
      addOptimisticArrangement(optimisticArr)
    })
    
    return createArrangement(formData)
  }, [song, createArrangement, addOptimisticArrangement, startTransition])
  
  return {
    arrangements: optimisticArrangements,
    createArrangement: createArrangementOptimistic,
    isPending
  }
}
```

---

## Key Implementation Gotchas

### 1. Musical Key Validation
- **CRITICAL**: Key field must be REQUIRED for transposition to work
- Use tonal.js for validation: `Key.majorKey(key).keySignature !== undefined`
- Support both major and minor keys: 'C', 'Am', 'F#', 'Bb', etc.

### 2. Title Generation
- **Pattern**: "[Song Name] - [Arrangement Name]"
- User can ONLY edit arrangement name portion
- Auto-generate full title in real-time as user types
- Display generated title prominently in form

### 3. Form Validation Timing
- **Follow Song Pattern**: "Reward Early, Punish Late"
- Show success states immediately (green border, checkmark)
- Delay error display until field blur
- Real-time validation after first error

### 4. ChordPro Integration
- Pre-fill editor with metadata directives: `{title}`, `{key}`, `{tempo}`
- Store template in sessionStorage for editor pickup
- Navigate to ChordPro editor AFTER arrangement creation, not during

### 5. Database Constraints
- Ensure arrangements.key column has NOT NULL constraint
- Add composite unique constraint on (song_id, slug)
- Create indexes for song_id, key, difficulty for performance

---

## Critical Success Factors

1. **Follow Existing Patterns Exactly**: Mirror SongManagementForm structure completely
2. **Musical Validation**: Implement robust key and tempo validation using tonal.js
3. **Auto-Title Generation**: Real-time title preview following "[Song] - [Arrangement]" format
4. **Optimistic UI**: Use React 19's useOptimistic for instant feedback
5. **Complete Vertical Slice**: Types → Service → Hooks → Components → Tests
6. **ChordPro Integration**: Seamless transition to editor with pre-filled metadata

This guide ensures one-pass implementation success by providing all critical patterns and gotchas discovered through comprehensive research.